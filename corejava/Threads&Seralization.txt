Threads  
-------

We can define a Thread in the following 2 way
1. By extending Thread class.
2. By implementing Runnable interface

If multiple Threads are waiting to execute then which Thread will execute 1st is
decided by "Thread Scheduler" which is part of JVM.

For every Thread the required mandatory activities like registering the Thread with
Thread Scheduler will takes care by Thread class start() method and programmer is
responsible just to define the job of the Thread inside run() method.

Among the 2 ways of defining a Thread, implements Runnable approach is
always recommended.In the 1st approach our class should always extends Thread class there is no
chance of extending any other class hence we are missing the benefits of
inheritance.But in the 2nd approach while implementing Runnable interface we can extend
some other class also. Hence implements Runnable mechanism is recommended
to define a Thread


Note: We can get current executing Thread object reference by using
Thread.currentThread() method.

Every Thread in java has some priority it may be default priority generated by
JVM (or) explicitly provided by the programmer

Thread. MIN_PRIORITY----------1
Thread. MAX_PRIORITY----------10
Thread. NORM_PRIORITY--------5

Thread scheduler uses these priorities while allocating CPU

If 2 Threads having the same priority then we can't expect exact execution order
it depends on Thread scheduler whose behavior is vendor dependent

The allowed values are 1 to 10 otherwise we will get runtime exception saying
"IllegalArgumentException".


public static native void yield();
yield() method causes "to pause current executing Thread for giving the chance
of remaining waiting Threads of same priority".

Join():
If a Thread wants to wait until completing some other Thread then we should go for
join() method.
Example: If a Thread t1 executes t2.join() then t1 should go for waiting state until
completing t2.
1. public final void join()throws InterruptedException
2. public final void join(long ms) throws InterruptedException
3. public final void join(long ms,int ns) throws InterruptedException



Note :
If main thread calls join() on child thread object and child thread called join() on main
thread object then both threads will wait for each other forever and the program will be
hanged(like deadlock if a Thread class join() method on the same thread itself then the
program will be hanged ).

Sleep() method:
If a Thread don't want to perform any operation for a particular amount of time then
we should go for sleep() method.
1. public static native void sleep(long ms) throws InterruptedException
2. public static void sleep(long ms,int ns)throws InterruptedException


How a Thread can interrupt another thread ?
If a Thread can interrupt a sleeping or waiting Thread by using interrupt()(break off)
method of Thread class.
public void interrupt();



Serialization: (1.1 v)
1. The process of saving (or) writing state of an object to a file is called serialization
2. but strictly speaking it is the process of converting an object from java supported
form to either network supported form (or) file supported form.

De-Serialization:
1. The process of reading state of an object from a file is called DeSerialization
2. but strictly speaking it is the process of converting an object from file supported
form (or) network supported form to java supported form

Note:****
	1. We can perform Serialization only for Serilizable objects.
	2. An object is said to be Serilizable if and only if the corresponding class
	implements Serializable interface.
	3. Serializable interface present in java.io package and does not contain any
	methods. It is marker interface. The required ability will be provided
	automatically by JVM.
	4. We can add any no. Of objects to the file and we can read all those objects from
	the file but in which order we wrote objects in the same order only the objects
	will come back. That is order is important.
	5. If we are trying to serialize a non-serializable object then we will get
	RuntimeException saying "NotSerializableException".



Transient keyword:
1. transient is the modifier applicable only for variables.
2. While performing serialization if we don't want to save the value of a particular
variable to meet security constant such type of variable , then we should declare
that variable with "transient" keyword.
3. At the time of serialization JVM ignores the original value of transient variable
and save default value to the file .

Static&Transiant
1. static variable is not part of object state hence they won't participate in
serialization because of this declaring a static variable as transient there is no
use
Final&Transiant
1. final variables will be participated into serialization directly by their values.
Hence declaring a final variable as transient there is no use.
//the compiler assign the value to final variable



We can implements customized serialization by using the following two methods.
1. 
 throws Exception.
This method will be executed automatically by jvm at the time of serialization.
It is a callback method. Hence at the time of serialization if we want to perform
any extra work we have to define that in this method only.
(prepare encrypted password and write encrypted password seperate to the file )
2. private void readObject(ObjectInputStream is) throws Exception.
This method will be executed automatically by JVM at the time of
Deserialization. Hence at the time of Deserialization if we want to perform any
extra activity we have to define that in this method only.
(read encrypted password , perform decryption and assign decrypted password
to the current object password variable )


At the time of Account object serialization JVM will check is there any writeObject()
method in Account class or not. If it is not available then JVM is responsible to perform
serialization(default serialization). If Account class contains writeObject() method then
JVM feels very happy and executes that Account class writeObject() method. The same
rule is applicable for readObject() method also.


Case 1:
If parent class implements Serializable then automatically every child class by default
implements Serializable. That is Serializable nature is inheriting from parent to child.
Hence even though child class doesn't implements Serializable , we can serialize child
class object if parent class implements serializable interface.

Even though parent class does not implements Serializable we can serialize child
object if child class implements Serializable interface.
2. At the time of serialization JVM ignores the values of instance variables which
are coming from non Serializable parent then instead of original value JVM
saves default values for those variables to the file.
3. At the time of Deserialization JVM checks whether any parent class is non
Serializable or not. If any parent class is non Serializable JVM creates a separate
object for every non Serializable parent and shares its instance variables to the
current object









