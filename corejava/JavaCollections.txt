Personal Question to understand?
Why StringBuffer class not implemented comparable interface?
how comparator intreface compare hetrogenous objects? 
how Treeset is doing defult natural sorting order?


Java Collections
-------------------
java.util.Collections class contain longlist of utiliy methods 

addAll()
binarySearch()
copy()
reverse()
shuffle()
sort()
copy()
min()
max()
replaceAll()
unmodifiableSet()

2)binarySearch()
----------------
The Collections binarySearch() method can search a Java List for an element using a binary search algorithm. 
The List must be sorted in ascending order before you search it using binarySearch() . 
See the tutorial about sorting Java Lists for more information about how to sort a List in ascending order.
Here is an example of searching a List using the Collections binarySearch() method:

List<String> list = new ArrayList<>();
list.add("one");
list.add("two");
list.add("three");
list.add("four");
list.add("five");

Collections.sort(list);

int index = Collections.binarySearch(list, "four");

System.out.println(index);

3)Copy()
----------
List<String> source = new ArrayList<>();
Collections.addAll(source, "e1", "e2", "e3");

List<String> destination = new ArrayList<>();
Collections.copy(destination, source);

4)reverse()
-------------
List>String< list = new ArrayList<String>();

list.add("one");
list.add("two");
list.add("three");

Collections.reverse(list);

5) replaceAll()
----------------
List source = new ArrayList();
source.add("A");
source.add("B");
source.add("A");

boolean replacedAny = source.replaceAll(source, "A", "C");

6)sort()
---------
List>String< list = new ArrayList<String>();

list.add("one");
list.add("two");
list.add("three");
list.add("four");

Collections.sort(list);

7)replaceAll()
--------------
List source = new ArrayList();
source.add("A");
source.add("B");
source.add("A");
boolean replacedAny = source.replaceAll(source, "A", "C");

8)unmodifiableSet()
-------------------
The unmodifiableSet() method in the Java Collections class can create an immutable (unmodifiable) Set from a normal Java Set . 
Here is a Java example of creating an immutable Set from a normal Set:
Set normalSet    = new HashSet();
Set immutableSet = Collections.unmodifiableSet(normalSet);


9)reverse() vs reverseOrder() method  
-------------------------------------
We can use reverse() method to reverse the elements of List.
Where as we can use reverseOrder() method to get reversed Comparator.

comparater c1 = Collections.reverseOrder(Comparator c)
c1 -> Desending order 
c-> Assending order 

ArrayList l=new ArrayList();   
l.add(15);
l.add(0);
l.add(20);
l.add(10);
l.add(5);
System.out.println(l);//[15, 0, 20, 10, 5]
Collections.reverse(l);
System.out.println(l);//[5, 10, 20, 0, 15] 


Comparable & Comparater
------------------------
****
Comparable:(java.lang package)
Comparable interface present in java.lang package and contains only one method compareTo() method. 
public int compareTo(Object obj); 

If we are not satisfying with default natural sorting order (or) 
if default natural sorting order is not available then we can define our own customized sorting by Comparator object.
Comparable meant for default natural sorting order.
Comparator meant for customized sorting order. 




public class Employee implements Comparable<Employee> {
 
    private Long id;
    private String name;
    private LocalDate dob;
     
    @Override
    public int compareTo(Employee o)  // The limitation of comparable we can able to sort based on single property.
    {
        return this.getId().compareTo( o.getId() );
    }
}



Collections.sort()
Use Collections.sort() method sort a list of objects.
Use Arrays.sort() method sort an array of objects.

Collections.reverseOrder()
This utility method returns a Comparator that imposes the reverse of the natural ordering on a collection of objects that implement the Comparable interface.
This enables a simple idiom for sorting (or maintaining) collections (or arrays) of objects that implement the Comparable interface in reverse-natural-order.

ArrayList<String> list = new ArrayList<>();
 
list.add("E");
list.add("A");
list.add("C");
list.add("B");
list.add("D");
 
//Sort in reverse natural order
Collections.sort(list, Collections.reverseOrder());





Comparator interface: (java.util package )
---------------------
Comparator interface present in java.util package this interface defines the following 2 methods.  
1) public int compare(Object obj1,Object Obj2); 

$$$$$$
If you want sorting should be happen in multiple properties then Comparator


Note: Whenever we are defining our own customized sorting by Comparator then the objects need not be Comparable. Example: StringBuffer


Sorting string based on length
-------------------------------
import java.util.*; 
class TreeSetDemo  { 
 public static void main(String[] args)   {
   TreeSet t=new TreeSet(new MyComparator()); 
  t.add("A"); 
  t.add(new StringBuffer("ABC"));
  t.add(new StringBuffer("AA"));
  t.add("xx");  
  t.add("ABCD");
  t.add("A");   
  System.out.println(t);//[A, AA, xx, ABC, ABCD]  
 }
} 


class MyComparator implements Comparator {  
public int compare(Object obj1,Object obj2)   {
   String s1=obj1.toString();
   String s2=obj2.toString();   
   int l1=s1.length();   
   int l2=s2.length();   
   if(l1 < l2)    
    return -1;   
   else if(l1 > l2)
   return 1;   
   else    
   return s1.compareTo(s2); 
}


Comparable vs Comparator: 
For predefined Comparable classes default natural sorting order is already available 
if we are not satisfied with default natural sorting order then we can define our own customized sorting order by Comparator. 

For predefined non Comparable classes [like StringBuffer] default natural sorting order is not available we can define our own sorting order by using Comparator object.
For our own classes [like Customer, Student, and Employee] we can define default natural sorting order by using Comparable interface. 

The person who is using our class, if he is not satisfied with default natural sorting order then he can define his own sorting order by using Comparator object. 


Java 8 comparable and comparater examples
----------------------------------------
1) Sort stream elements in natural order
   List<Integer> list = Arrays.asList(2, 4, 1, 3, 7, 5, 9, 6, 8);
   List<Integer> sortedList = list.stream().sorted().collect(Collectors.toList());
2) reverse order using a comparator.
   List<Integer> list = Arrays.asList(2, 4, 1, 3, 7, 5, 9, 6, 8);
   List<Integer> sortedList = list.stream().sorted(Comparator.reverseOrder())
					   .collect(Collectors.toList());
3)Sort stream elements using custom comparator
  List<Integer> list = Arrays.asList(2, 4, 1, 3, 7, 5, 9, 6, 8);
         
  Comparator<Integer> reverseComparator = new Comparator<Integer>() {
  @Override
  public int compare(Integer i1, Integer i2) {
                return i2.compareTo(i1);
            }
  }; 
 
  List<Integer> sortedList = list.stream()
                    .sorted(reverseComparator)
                    .collect(Collectors.toList());
4)Sort stream elements using lambda expression 
     List<Integer> list = Arrays.asList(2, 4, 1, 3, 7, 5, 9, 6, 8);
 
        List<Integer> sortedList = list.stream()
                    .sorted( (i1, i2) -> i2.compareTo(i1) )
                    .collect(Collectors.toList());
 

List
--------
If we want to represent a group of individual objects as a single entity 
where "duplicates are allow and insertion order must be preserved" then we should go for List interface. 

public void clear()
--------------------
The clear() method of List interface in Java is used to remove all of the elements from the List container. 
This method does not deleted the List container, instead it justs removes all of the elements from the List.

Since List is an interface you need to instantiate a concrete implementation of the interface in order to use it. 
You can choose between the following List implementations in the Java Collections API:
java.util.ArrayList
java.util.LinkedList
java.util.Vector
java.util.Stack
java.util.concurrent.CopyOnWriteArrayList

*************************************************************************************************************
ArrayList: 
1. The underlying data structure is resizable array (or) growable array.
2. Duplicate objects are allowed. 
3. Insertion order preserved. 
4. Heterogeneous objects are allowed.(except TreeSet , TreeMap every where heterogenious objects are allowed)
5. Null insertion is possible
Creates an empty ArrayList object with default initial capacity "10" if ArrayList reaches its max capacity then a new ArrayList object will be created with 
New capacity=(current capacity*3/2)+1

How to convert List to set ?
//Converting to set using stream 
Set<String> set = aList.stream().collect(Collectors.toSet()); 
// Creating a list of strings 
List<String> aList = Arrays.asList("Geeks", "for", "GeeksQuiz", "GeeksforGeeks", "GFG"); 
Set<String> hSet = new HashSet<String>(aList); 
//adding the list
Set set = new HashSet();
set.addAll(list);

List to array
Object[] objects = list.toArray();

Array to list
String[] values = new String[]{ "one", "two", "three" };
List list = Arrays.asList(values);


ArrayListInterview Questions?
1. How to remove duplicates from ArrayList in Java?  (Answer)
2) How to reverse ArrayList in Java? (Answer) ->Collections.reverse()
3) How to synchronize ArrayList in Java? (Answer) --> Collections.synchronizedList()
4) How to sort ArrayList in Java?  -->Collections.sort();

5) How to convert ArrayList to String in Java? 

List<String> list = Arrays.asList("java", "python", "nodejs", "ruby");
//java, python, nodejs, ruby 
String result = String.join(", ", list);
List<String> list = Arrays.asList("java", "python", "nodejs", "ruby");
//java | python | nodejs | ruby
String result = list.stream().map(x -> x).collect(Collectors.joining(" | "));
//2015-10-31
String result = String.join("-", "2015", "10", "31" );
----------------------------------------------------------------------------
6)How to Make Collection like ArrayList Read Only in Java?

	Collections.unmodifiableList()
You can create read-only Collection by using Collections.unmodifiableCollection() utility method.
it returns a unmodifiable or read-only view of Collection in which you can not perform any operation
which will change the collection like add() , remove() and set() either directly or while iterating using Iterator or ListIterator. 
It will throw UnsupportedOperationException
                 (Or)

java.lang.Object
   java.util.AbstractCollection
       com.google.common.collect.ImmutableCollection
           com.google.common.collect.ImmutableList 

Immutable List in Java
------------------------
ImmutableList, as suggested by the name, is a type of List which is immutable. It means that the content of the List are fixed or constant after declaration, that is, they are read-only.
If any attempt made to add, delete and update elements in the List, UnsupportedOperationException is thrown.
An ImmutableList does not allow null element either.
If any attempt made to create an ImmutableList with null element, NullPointerException is thrown. If any attempt is made to add null element in List, UnsupportedOperationException is thrown.

Advantages of ImmutableList
----------------------------
They are thread safe.
They are memory efficient.
Since they are immutable, hence they can be passed over to third party libraries without any problem.
-----------------------------------------------------------------------------------

7)How to sort ArrayList in descending order in Java?

We are using Collections.reverseOrder() method along with Collections.sort() in order to sort the list in decreasing order. 
In the below example we have used the following statement for sorting in reverse order.
Collections.sort(arraylist, Collections.reverseOrder());

However the reverse order sorting can also be done as following – This way the list will be sorted in ascending order first and then it will be reversed.
Collections.sort(list);
Collections.reverse(list);

8)How to find the last occurance of the list ?
list.lastIndexOf(element1);

**************************************************************************************************************************
Linked List:
1. The underlying data structure is double LinkedList
2. If our frequent operation is insertion (or) deletion in the middle then LinkedList is the best choice.
3. If our frequent operation is retrieval operation then LinkedList is worst choice. 
4. Duplicate objects are allowed. 
5. Insertion order is preserved. 
6. Heterogeneous objects are allowed. 
7. Null insertion is possible.
8. Implements Serializable and Cloneable interfaces but not RandomAccess.
Usually we can use LinkedList to implement Stacks and Queues. To provide support for this requirement LinkedList class defines the following 6 specific methods. 
1. void addFirst(Object o); 2. void addLast(Object o); 3. Object getFirst(); 4. Object getLast(); 5. Object removeFirst(); 6. Object removeLast(); 

pending interview Questions

******************************************************************************************************************************
Vector:
Every method present in Vector is synchronized and hence Vector is Thread safe. 

Drawbacks of vector 
It methods are synchronized it causes performance slow 

Taking more memory causing problem
Vector v=new Vector();  
Creates an empty Vector object with default initial capacity 10. 
Once Vector reaches its maximum capacity then a new Vector object will be created with double capacity. That is "newcapacity=currentcapacity*2".
********************************************************************************************************************************
Stack:

1. It is the child class of Vector. 
2. Whenever last in first out(LIFO) order required then we should go for Stack. 
Constructor: 
It contains only one constructor. 
Stack s= new Stack();

*********************************************************************************************************************

CopyOnWriteArrayList
-------------------------
This means that a CopyOnWriteArrayList (and CopyOnWriteArraySet) is mostly useful when you have few modifications
 but many reads because reads are very cheap and don’t require synchronization.

Conclusion:
CopyOnWriteArrayList and CopyOnWriteArraySet (which is implemented with a CopyOnWriteArrayList) are special data structures 
for use cases where you want to share the data structure among several threads and have few writes and many reads.
Always make sure to do a performance test for your code on real hardware to see how it performs in your application
.And make sure to read the javadoc for all the methods to really understand how the data structures work.
Of course you can also use CopyOnWriteArrayList and CopyOnWriteArraySet from other JVM languages like Scala, Clojure, JRuby or Groovy.

Immutable collections.
Sometimes you just need to create the list or set once and then later only read from it. 
In this case I recommend having a look at the immutable collections from Guava..
They are always thread safe (as is every really immutable object) and are a better alternative to the wrapped immutable collections that come with the JDK. See the Guava website for why that is the case.

The design of the CopyOnWriteArrayList uses an interesting technique to make it thread-safe without a need for synchronization. 
When we are using any of the modify methods – such as add() or remove() 
– the whole content of the CopyOnWriteArrayList is copied into the new internal copy.

Due to this simple fact, we can iterate over the list in a safe way, even when concurrent modification is happening.

When we’re calling the iterator() method on the CopyOnWriteArrayList, we get back an Iterator backed up by the immutable snapshot of the content of the CopyOnWriteArrayList.

Its content is an exact copy of data that is inside an ArrayList from the time when the Iterator was created. 
Even if in the meantime some other thread adds or removes an element from the list,
that modification is making a fresh copy of the data that will be used in any further data lookup from that list.

The characteristics of this data structure make it particularly useful in cases when we are iterating over it more often than we are modifying it.
If adding elements is a common operation in our scenario, then CopyOnWriteArrayList won’t be a good choice
 – because the additional copies will definitely lead to sub-par performance.

Let’s say that we’re creating an instance of the CopyOnWriteArrayList that stores integers:

CopyOnWriteArrayList<Integer> numbers 
  = new CopyOnWriteArrayList<>(new Integer[]{1, 3, 5, 8});
Next, we want to iterate over that array, so we are creating an Iterator instance:


Iterator<Integer> iterator = numbers.iterator();
After the Iterator is created, we are adding a new element to the numbers list:

numbers.add(10);
Keep in mind that, when we create an iterator for the CopyOnWriteArrayList, we get an immutable snapshot of the data in the list at the time iterator() was called.

Because of that, while iterating over it, we won’t see the number 10 in the iteration:

List<Integer> result = new LinkedList<>();
iterator.forEachRemaining(result::add);
  
assertThat(result).containsOnly(1, 3, 5, 8);



how to solve ConcurrentModificationException 
---------------------------------------------
Create class CrunchifyCopyOnWriteArrayList.java
Create a List companies
Add 5 values to companies and iterate through List
While iterating modify (add/remove) elements from List
You will see ConcurrentModificationException because its internal modCount was what tipped off the iterator


ArrayList Vs LinkedList
-----------------------
1) Search: ArrayList search operation is pretty fast compared to the LinkedList search operation.
get(int index) in ArrayList gives the performance of O(1) while LinkedList performance is O(n).
Reason: ArrayList maintains index based system for its elements as it uses array data structure implicitly 
which makes it faster for searching an element in the list.On the other side 
LinkedList implements doubly linked list which requires the traversal through all the elements for searching an element.

2)Deletion: LinkedList remove operation gives O(1) performance 
while ArrayList gives variable performance: O(n) in worst case (while removing first element) and O(1) in best case (While removing last element).
Conclusion: LinkedList element deletion is faster compared to ArrayList.
Reason: LinkedList’s each element maintains two pointers (addresses) which points to the both neighbor elements in the list. 
Hence removal only requires change in the pointer location in the two neighbor nodes (elements) of the node which is going to be removed. 
While In ArrayList all the elements need to be shifted to fill out the space created by removed element.

3)Inserts Performance: LinkedList add method gives O(1) performance while ArrayList gives O(n) in worst case. Reason is same as explained for remove.

4)Memory Overhead: ArrayList maintains indexes and element data 
while LinkedList maintains element data and two pointers for neighbor nodes 
hence the memory consumption is high in LinkedList comparatively.

There are few similarities between these classes which are as follows:
They both maintain the elements insertion order which means while displaying ArrayList and LinkedList elements 
the result set would be having the same order in which the elements got inserted into the List.

Both these classes are non-synchronized and can be made synchronized explicitly by using Collections.synchronizedList method.
The iterator and listIterator returned by these classes are fail-fast (if list is structurally modified at any time after the iterator is created,
in any way except through the iterator’s own remove or add methods, the iterator will throw a ConcurrentModificationException).

When to use LinkedList and when to use ArrayList?
1) As explained above the insert and remove operations give good performance (O(1)) in LinkedList compared to ArrayList(O(n)). 
Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.
2) Search (get method) operations are fast in Arraylist (O(1)) but not in LinkedList (O(n)) 
so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.


Set
----
If we want to represent a group of individual objects as single entity
"where duplicates are "not allow" and insertion order is not preserved" then we should go for Set interface

Since Set is an interface you need to instantiate a concrete implementation of the interface in order to use it. 
You can choose between the following Set implementations in the Java Collections API:
java.util.EnumSet
java.util.HashSet
java.util.LinkedHashSet
java.util.TreeSet


HashSet is backed by a Hashtable. It makes no guarantees about the sequence of the elements when you iterate them.

LinkedHashSet differs from HashSet by guaranteeing that the order of the elements during iteration is the same as the order they were inserted into the LinkedHashSet.
Reinserting an element that is already in the LinkedHashSet does not change this order.

*********************************************************************************************************
HashSet: 
1. The underlying data structure is Hashtable. 
2. Insertion order is not preserved and it is based on hash code of the objects.
3. Duplicate objects are not allowed. 
4. If we are trying to insert duplicate objects we won't get compile time error and runtime error add() method simply returns false. 
5. Heterogeneous objects are allowed. 
6. Null insertion is possible.(only once) 
7. Implements Serializable and Cloneable interfaces but not RandomAccess.
8. HashSet is best suitable, if our frequent operation is "Search". 

HashSet h=new HashSet(); 
Creates an empty HashSet object with default initial capacity 16 and default fill ratio 0.75(fill ratio is also known as load factor). 

HashSet clone() internally follows shallow clone

1)How HashSet Works Internally In Java?
HashSet uses HashMap internally to store it’s objects.
Whenever you create a HashSet object, one HashMap object associated with it is also created.
This HashMap object is used to store the elements you enter in the HashSet.
The elements you add into HashSet are stored as keys of this HashMap object.
The value associated with those keys will be a constant.

2)How HashSet Works Internally In Java?
Whenever you insert an element into HashSet using add() method, 
it actually creates an entry in the internally backing HashMap object with element you have specified as it’s key and constant called “PRESENT” as it’s value.
This “PRESENT” is defined in the HashSet class as below.


3)  Why HashSet does not have get(Object o) method ?
Most of the people get puzzled by hearing this question . 
This question tests the deep understanding of the HashSet class .
This question helps the interviewer to know whether candidate has the idea about contains() method in HashSet  class or not .
So let jump to the answer
get(Object o) is useful when we have one information linked to other information just like key value pair found in HashMap .
So using get() method on one information we can get the second information or vice-versa.

Unlike HashMap , HashSet is all about having unique values or unique objects . 
There is no concept of keys in HashSet .
The only information we can derive from the HashSet object is whether the element is present in the HashSet Object or not .
If the element is not present in the HashSet then add it otherwise return true leaving HashSet object unchanged. 
Here, contains() method helps to provide this information.


4) What is and when to use Collections.emptySet() . What is the advantage of having emptySet in Collections class ?

According to Oracle docs ,Collections.emptySet() returns the empty immutable Set ,not containing null  .
Advantages of using emptySet() method over creating object using constructor are :
1. Immutable : You should prefer to use immutable collection against the mutable collections wherever possible . 
It becomes handy as multiple threads accessing the same instance of  object will see the same values.
2. Concise :  You do not need to manually type out the generic type of the collection
 -  normally it is inferred from the context of the method call.
3. Efficient : As emptySet() method dont create new objects , so they just reuse the existing empty and immutable object . 
Although ,practically,this trick is not that handy , and rarely improves the performance


5)How to convert HashSet into array in Java? => toArray()
Set<String> stringSet = new HashSet<String>();
String[] strArray = stringSet.toArray();

**********************************************************************************************************
 
LinkedHashSet: 
1. It is the child class of HashSet. 2. LinkedHashSet is exactly same as HashSet except the following differences.
Differences
LinkedHashSet 
1) The underlying data structure is a combination of LinkedList and Hashtable. 
2) Insertion order is preserved.
Hashset
1) The underlying data structure is Hashtable. 
2) Insertion order is not preserved. 
 
************************************************************************************************************************

SortedSet:
----------
1. It is child interface of Set. 
2. If we want to represent a group of "unique objects" where duplicates are not allowed and all objects must be
 inserting according to some sorting order then we should go for SortedSet interface.
3. That sorting order can be either default natural sorting (or) customized sorting order. 

methods
-------
1. Object first();
2. Object last(); 
3. SortedSet headSet(Object obj);  Returns the SortedSet whose elements are <obj. 
4. SortedSet tailSet(Object obj);  It returns the SortedSet whose elements are >=obj.
5. SortedSet subset(Object o1,Object o2);  Returns the SortedSet whose elements are >=o1 but <o2.  
6. Comparator comparator();   Returns the Comparator object that describes underlying sorting technique. 
If we are following default natural sorting order then this method returns null. 


import java.util.Comparator; 
import java.util.TreeSet; 
   
class The_Comparator implements Comparator<String> { 
    public int compare(String str1, String str2) 
    { 
        String first_Str; 
        String second_Str; 
        first_Str = str1; 
        second_Str = str2; 
        return second_Str.compareTo(first_Str); 
    } 
} 
   
public class Tree_Set_Demo { 
    public static void main(String[] args) 
    { 
    	
        //TreeSet<String> tree_set = new TreeSet<String>(); when Comparator is null then default sorting order 
        TreeSet<String> tree_set = new TreeSet<String>(new The_Comparator()); 
	// when Comparator object the customized  sorting order 
   
        tree_set.add("F"); 
        tree_set.add("B"); 
        tree_set.add("D"); 
        tree_set.add("C"); 
        tree_set.add("A"); 
        tree_set.add("A"); 
       
        System.out.println("Set before using the comparator: "+ 
        tree_set); 
   
        System.out.println("The elements sorted in descending"+ 
        "order:"); 
        for (String element : tree_set) 
            System.out.print(element + " "); 
    } 
} 

Set before using the comparator: [F, D, C, B, A]
The elements sorted in descendingorder:
F D C B A 

**********************************************************************************************************************
NavigableSet: 
1. It is the child interface of SortedSet. 
2. It provides several methods for navigation purposes. 

Methods
--------
NavigableSet interface defines the following methods.  
1. ceiling(e);  It returns the lowest element which is >=e. 
2. higher(e); It returns the lowest element which is >e. 
3. floor(e);  It returns highest element which is <=e.
4. lower(e);  It returns height element which is <e. 
5. pollFirst (); Remove and return 1st element. 
6. pollLast (); Remove and return last element. 
7. descendingSet (); Returns SortedSet in reverse order. 

descendingIterator() and descendingSet()
----------------------------------------
The descendingSet() method returns a NavigableSet in which the order of the elements is reversed compared to this one. 
The returned "view" is backed by the original NavigableSet, so changes to the descending set are also reflected in the original set
NavigableSet reverse = original.descendingSet();

The descendingIterator() method allows you to iterate the elements of the NavigableSet (which is also a SortedSet) in reverse order,
without changing the order of the elements internally.
Iterator reverse = original.descendingIterator();  


Example:  import java.util.*; 
class NavigableSetDemo  {
  public static void main(String[] args)   {  
 TreeSet<Integer> t=new TreeSet<Integer>();   
t.add(1000);  
t.add(2000);   
t.add(3000);  
t.add(4000);   
t.add(5000);   
System.out.println(t);//[1000, 2000, 3000, 4000, 5000]   
System.out.println(t.ceiling(2000));//2000   
System.out.println(t.higher(2000));//3000  
System.out.println(t.floor(3000));//3000   
System.out.println(t.lower(3000));//2000  
System.out.println(t.pollFirst());//1000  
System.out.println(t.pollLast());//5000   
System.out.println(t.descendingSet());//[4000, 3000, 2000]   
System.out.println(t);//[2000, 3000, 4000]  
 } 
} 

*****************************************************************************************************

TreeSet:
--------- 
1. The underlying data structure is balanced tree.
2. Duplicate objects are not allowed. 
3. Insertion order is not preserved and it is based on some sorting order of objects.
4. Heterogeneous objects are not allowed if we are trying to insert heterogeneous objects then we will get ClassCastException. 
5. Null insertion is possible(only once).

Null acceptance: 
Allows NULL insertion but maximum of only one NULL value (till Java 1.6 version)
From Java 1.7 version, NULL insertion is not possible

Example for converting hashset to treeset
-----------------------------------------
List<String> list = Arrays.asList("1","2","3","4");
Set<String> s = list.stream().map(x-> x).collect(Collectors.toSet());
Set<String> treeset  = s.stream().collect(Collectors.toCollection(TreeSet::new));
System.out.println(treeset);


Note: 

 Exception in thread "main" java.lang.ClassCastException: java.lang.StringBuffer cannot be cast to java.lang.Comparable
 If we are depending on default natural sorting order compulsory the objects should be homogeneous and Comparable otherwise we will get ClassCastException. 
 An object is said to be Comparable if and only if the corresponding class implements Comparable interface.
 String class and all wrapper classes implements Comparable interface but StringBuffer class doesn't implement Comparable interface 
 shence in the above program we are getting ClassCastException. 

-------------------------------------------------


public final class String
extends Object
implements Serializable, Comparable<String>, CharSequence

// creating TreeSet object using Set reference-type
 Set<String> string = new TreeSet<String>();

// adding/storing String value/objects
        string.add("Thuppakki");
        string.add("Kaththi");
        string.add("Bairavaa");
        string.add("Mersal");
        string.add("Sarkar");

output: [Bairavaa, Kaththi, Mersal, Sarkar, Thuppakki]

When String value/objects are stored/added to TreeSet class, then it stores values in natural sorting-order i.e.; value/objects are sorted in alphabetical order
Reason: String implements java.lang.Comparable interface which helps to sort among one-another while storing/adding value/objects itself in TreeSet
As you can see from above program display/output, String value/objects are printed in the natural alphabetic order

--------------------------------------------------

public final class StringBuffer
extends Object
implements Serializable, CharSequence

public final class StringBuilder
extends Object
implements Serializable, CharSequence

Same below for StringBuilder as well
 
// creating TreeSet object using Set reference-type
Set<StringBuffer> strBuffer = new TreeSet<StringBuffer>();
 
// adding/storing String value/objects
 strBuffer.add(new StringBuffer("Thuppakki"));
 strBuffer.add(new StringBuffer("Kaththi"));
 strBuffer.add(new StringBuffer("Bairavaa"));
 strBuffer.add(new StringBuffer("Mersal"));
 strBuffer.add(new StringBuffer("Sarkar"));

When StringBuffer value/objects are stored/added to TreeSet class, then no error is thrown during compilation
But at runtime or during execution of program, a java.lang.ClassCastException is thrown as shown in the output console
Error: what ClassCastException describe in the above screen-capture  is that “java.lang.StringBuffer cannot be cast to java.lang.Comparable”

Reason: StringBuffer do not implements java.lang.Comparable interface, as shown StringBuffer signature above
While storing/adding StringBuffer value/objects to TreeSet class, it doesn’t understand on what basis these value/objects need to be sorted
So, we need to add/store only those values to TreeSet class, which is comparable among each other
Therefore, we must define explicit custom comparator for StringBuffer class and pass it as constructor-argument, as described in the following section

To solve this problem
---------------------
First, we need define StringBuffer comparator by implementing java.util.Comparator interface and providing logic for compare() method
Here, we compared StringBuffer objects using compareTo() method of java.lang.Comparable interface, after converting StringBuffer object into String object
Thereby, String comparison yields sorting in alphabetically natural-order
Note: just interchanging sbf1 with sbf2 will yield results in reverse-order


StringBufferCustomComparator.java
----------------------------------

package in.bench.resources.sorting.string;
 
import java.util.Comparator;
 
public class StringBufferCustomComparator 
                        implements Comparator<StringBuffer> {
 
    @Override
    public int compare(StringBuffer sbf1, StringBuffer sbf2) {
        return sbf1.toString().compareTo(sbf2.toString()); 
    }
}

SortingStringBufferUsingCustomComparator.java
-----------------------------------------------
package in.bench.resources.sorting.string;
 
import java.util.Set;
import java.util.TreeSet;
 
public class SortingStringBufferUsingCustomComparator {
 
    public static void main(String[] args) {
 
        // creating TreeSet object using Set reference-type
        // using customer-comparator as constructor-argument
        Set<StringBuffer> strBuffer = new TreeSet<StringBuffer>(
                new StringBufferCustomComparator());
 
        // adding/storing String value/objects
        strBuffer.add(new StringBuffer("Thuppakki"));
        strBuffer.add(new StringBuffer("Kaththi"));
        strBuffer.add(new StringBuffer("Bairavaa"));
        strBuffer.add(new StringBuffer("Mersal"));
        strBuffer.add(new StringBuffer("Sarkar"));
 
        // displaying/printing String value/objects
        System.out.println(strBuffer);
    }
}
Output:
[Bairavaa, Kaththi, Mersal, Sarkar, Thuppakki]


***************************************************************************
EnumSet:


Why Use EnumSet
As a rule of thumb, EnumSet should always be preferred over any other Set implementation when we are storing enum values.


It extends AbstractSet and implements Set Interface in Java.
EnumSet class is a member of the Java Collections Framework & is not synchronized.
It’s a high performance set implementation, much faster than HashSet.
All of the elements in an enum set must come from a single enumeration type that is specified when the set is created either explicitly or implicitly.

EnumSet is a public abstract class that contains multiple static factory methods that allow us to create instances. 
The JDK provides 2 different implementations – are package-private and backed by a bit vector:

RegularEnumSet
-----------------


RegularEnumSet uses a single long to represent the bit vector. 
Each bit of the long element represents a value of the enum. 
The i-th value of the enum will be stored in the i-th bit, 
so it’s quite easy to know whether a value is present or not.
Since long is a 64-bit data type, this implementation can store up to 64 elements.

JumboEnumSet
----------------
JumboEnumSet uses an array of long elements as a bit vector. This lets this implementation store more than 64 elements.


Benefits from Using an EnumSet
------------------------------
Due to the implementation of an EnumSet that we’ve described above,
all the methods in an EnumSet are implemented using arithmetic bitwise operations.
These computations are very fast and therefore all the basic operations are executed in a constant time.


The majority of the methods of an EnumSet work like any other Set, with the exception of the methods to create instances.
In our examples, we’ll work with a Color enum:
public enum Color {
    RED, YELLOW, GREEN, BLUE, BLACK, WHITE
}


$$$$
The most simple methods to create an EnumSet are allOf() and noneOf().

This way we can easily create an EnumSet containing all the elements of our Color enum:
EnumSet.allOf(Color.class);

Likewise, we can use noneOf() to do the opposite and create an empty collection of Color:
EnumSet.noneOf(Color.class);

Another way to create a subset of an enum is by using the range() method:
EnumSet.range(Color.YELLOW, Color.BLUE);
output: [YELLOW, GREEN, BLUE]

Another useful factory method is the complementOf() that allows us to exclude the elements passed as parameters.
Let’s create an EnumSet with all the Color elements except black and white:

$$$$
EnumSet.complementOf(EnumSet.of(Color.BLACK, Color.WHITE));
If we print this collection we can see that it contains all the other elements:
[RED, YELLOW, GREEN, BLUE]


Finally, we can create an EnumSet by copying all the elements from another EnumSet:
EnumSet.copyOf(EnumSet.of(Color.BLACK, Color.WHITE));
Internally, it calls the clone method.

List<Color> colorsList = new ArrayList<>();
colorsList.add(Color.RED);
EnumSet<Color> listCopy = EnumSet.copyOf(colorsList);



import java.util.*;  
enum days {  
  SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY  
} 
 public class EnumSetExample {  
  public static void main(String[] args) {  
    Set<days> set = EnumSet.of(days.TUESDAY, days.WEDNESDAY);  
    // Traversing elements  
    Iterator<days> iter = set.iterator();  
    while (iter.hasNext())  
      System.out.println(iter.next());  
  }  
} 


enum days {  
  SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY  
}  
public class EnumSetExample {  
  public static void main(String[] args) {  
    Set<days> set1 = EnumSet.allOf(days.class);  
      System.out.println("Week Days:"+set1);  
      Set<days> set2 = EnumSet.noneOf(days.class);  
      System.out.println("Week Days:"+set2);     
************************************************************************************************************************
************************************************************************************************************************

Map:

The Java Map interface, java.util.Map, represents a mapping between a key and a value. More specifically, 
a Java Map can store pairs of keys and values. 


$$$$$$
1. If we want to represent a group of objects as "key-value" pair then we should go for Map interface.
2. Both key and value are objects only. 
3. Duplicate keys are not allowed but values can be duplicated 
4. Each key-value pair is called "one entry"
5. Map interface is not child interface of Collection and hence we can't apply Collection interface methods here. 


Map interface defines the following specific methods

1) Object put(Object key,Object value);  
   To add an entry to the Map, 
   if key is already available then the old value replaced with new value and old value will be returned.
2)void putAll(Map m);  
3)Object get(Object key); 
4)Object remove(Object key); It removes the entry associated with specified key and returns the corresponding value. 
5)boolean containsKey(Object key); 
6)boolean containsValue(Object value); 
7) boolean isEmpty(); 
8) Int size(); 
9) void clear(); 
10)Set keySet();  The set of keys we are getting. 
11)Collection values();  The set of values we are getting. 
12)Set entrySet();  The set of entryset we are getting.


Entry interface: 
----------------
Each key-value pair is called one entry. 
Hence Map is considered as a group of entry Objects, 
without existing Map object there is no chance of existing entry object 
hence interface entry is define inside Map interface(inner interface). 


Example:  
interface Map 
{   
.......
//map related methods
.......
........

 interface Entry {  
	     Object getKey();  
	     Object getValue();      //on Entry we can apply these 3 methods.    
             Object setValue(Object new);  
 } 
} 

Since Map is an interface you need to instantiate a concrete implementation of the Map interface in order to use it.
The Java Collections API contains the following Map implementations:
java.util.HashMap
java.util.Hashtable
java.util.EnumMap
java.util.IdentityHashMap
java.util.LinkedHashMap
java.util.Properties
java.util.TreeMap
java.util.WeakHashMap

*****************************************************************************************************************************************************

HashMap: 
1. The underlying data structure is Hashtable.
2. Duplicate keys are not allowed but values can be duplicated. 
3. Insertion order is not preserved and it is based on hash code of the keys.
4. Heterogeneous objects are allowed for both key and value.
5. Null is allowed for keys(only once) and for values(any number of times). 
6. It is best suitable for Search operations. 

Constructors: 
1. HashMap m=new HashMap();  
Creates an empty HashMap object with default initial capacity 16 and default fill ratio "0.75". 
2. HashMap m=new HashMap(int initialcapacity); 
3. HashMap m =new HashMap(int initialcapacity, float fillratio); 
4. HashMap m=new HashMap(Map m);


hashCode() and equals() methods have been defined in Object class which is parent class for java objects. 
For this reason, all java objects inherit a default implementation of these methods.

equals(Object otherObject) – As method name suggests, is used to simply verify the equality of two objects. 
It’s default implementation simply check the object references of two objects to verify their equality.
By default, two objects are equal if and only if they are stored in the same memory address.

hashcode() – Returns a unique integer value for the object in runtime.
By default, integer value is mostly derived from memory address of the object in heap (but it’s not mandatory always).
This hash code is used for determining the bucket location, when this object needs to be stored in some HashTable like data structure.

The Contract Between equals() and hashcode()
----------------------------------------------
The default implementation is not enough to satisfy business needs,
especially if we're talking about a huge application that considers two objects as equal when some business fact happens. 
In some business scenarios, developers provide their own implementation in order to force their own equality mechanism regardless the memory addresses.

$$$$$$$
As per the Java documentation, developers should override both methods in order to achieve a fully working equality mechanism
 — it's not enough to just implement the equals() method.

$$$$$$$
If two objects are equal according to the equals(Object) method, 
then calling the hashcode() method on each of the two objects must produce the same integer result.

$$$$$
When we overide the equals method it will check for content comparision
as per my business logic when to conents are same then objects should be same and hashcode should be same 
so we should overide the equals and hashcode

$$$$$$$$ 
It is not required that if two objects are unequal according to the equal(),
 then calling the hashcode method on each of the two objects must produce distinct values.

Depending on the hashing function, 2 different objects can have the same hash code. 
However, 2 objects which are the same must produce the same result when hashed (unless someone implemented a hashing function with random numbers in which case it's useless)

For example, if I am hashing integers and my hashing function is simply (n % 10) 
then the number 17 and the number 27 will produce the same result. This does not mean that those numbers are the same.

$$$$$$
Please verify the below example  without overiding  equals and hascode
with overiding 


equals() and hashCode() methods in Java
Java.lang.object has two very important methods defined: public boolean equals(Object obj) and public int hashCode().

equals() method
In java equals() method is used to compare equality of two Objects. The equality can be compared in two ways:

Shallow comparison: The default implementation of equals method is defined in Java.lang.Object class which simply checks if two Object references (say x and y) refer to the same Object.
i.e. It checks if x == y. Since Object class has no data members that define its state, it is also known as shallow comparison.
Deep Comparison: Suppose a class provides its own implementation of equals() method in order to compare the Objects of that class w.r.t state of the Objects. 
That means data members (i.e. fields) of Objects are to be compared with one another. Such Comparison based on data members is known as deep comparison.


Few Thump rules:
If two objects are same then they must return same value in hashcode() and equals() method whenever invoked.
It is not necessary that two different object must have different hashcode values. 
it might be possible that they share common hash bucket.

JVM assigns unique hashcode value to each object when they are created in memory and 
if developers don’t override the hashcode method then there is no way the two object returns same hashcode value.

As the question comes in your mind that equals() method is used to compare objects 
that they are having same value or not but why should we override the hashcode method ?

The answer to the question is for the hash technique based data structures like HashMap and HashTable.

As you can see in above diagram that every object is placed in Hash bucket depending on the hashcode they have. 
It is not necessary that every different object must have different hashcode. 
hashcode is used to narrow the search result.
When we try to insert any key in HashMap first it checks whether any other object present with same hashcode and if yes then it checks for the equals() method.
If two objects are same then HashMap will not add that key instead it will replace the old value by new one.


import java.util.HashMap;
import java.util.Map;

public class Practise {
	
	private void test() {
		Employee e = new Employee(1);
		Employee e1 = new Employee(1);
		
		Map<Employee, String> map = new HashMap<Employee, String>();
		map.put(e, "JACK");
		map.put(e1, "JACK");
		
		System.out.println(map.size()); 
		Integer i = new Integer(1);
		Integer i1 = new Integer(1);
		
		Map<Integer ,String>  map1 = new HashMap<>();
		map1.put(i ,"one");
		map1.put(i1,"one");
		
		System.out.println(map1.size()); 
		
	}

	
public static void main(String[] args) {
		
		Practise p = new Practise();
		p.test();
		
	}
}


class Employee{
	int id;

	  @Override public int hashCode() { 
		  final int prime = 31;
		  int result = 1;
	        result = prime * result + id; return result; 
	  }
	 
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Employee other = (Employee) obj;
		if (id != other.id)
			return false;
		return true;
	}

	public Employee(int id) {
		this.id = id;
	} 
	
}


Interview Questions

1)Difference between HashMap and Hashtable | HashMap Vs Hashtable ?

Both the HashMap and Hashtable implement the interface java.util.Map 
but there are some slight differences which has to be known to write a much efficient code.

The Most important difference between HashMap and the Hashtable is that Hashtable is synchronized and HashMap is non-synchronized , 
which means Hashtable is thread-safe and can be shared among multiple threads and you don’t need to worry about the synchronization problems. 
As only one thread can access the Hashtable at a time whereas Hashmap is not thread-safe and it cannot be shared between threads without synchronization. 
You can synchronize the HashMap using this below code.
Map m = Collections.synchronizedMap(hashMap);

HashMap permits one null key and multiple null values whereas the Hashtable will not allow null key or value.
Since the Hashtable is thread-safe it is comparatively slower than the HashMap in the environment where Synchronization factor is not considered.

HashMap can be traversed by using the iterator, 
whereas the Hashtable can be traversed by using enumerator and iterator.
HashMap inherits AbstractMap class and Hashtable inherits Dictionary class.


2) What is the threshold value after which bucket converted from linked list to Tree?
If for a given bucket, if there are more than 8 Nodes then the linked list is converted into a Red Black tree.
This is represented in the HashMap class code as follows :
static final int TREEIFY_THRESHOLD = 8;

3)What is the threshold value after which Tree is converted back to linked list?
If for a given bucket, if there are less than 6 Nodes then the Tree is converted back to the linked list. This is represented in the HashMap class code as follows :
static final int UNTREEIFY_THRESHOLD = 6
 
4) What is the difference between HashMap and ConcurrentHashMap in java ? (solution)
1. ConcurrentHashMap is thread-safe that is at a time only one thread can access the code whereas HashMap is not thread-safe.
2. ConcurrentHashMap does not allow keys to contain null values whereas HashMap can contain one null key.



************************************************************************************************************
LinkedHashMap
--------------
Note: in general we can use LinkedHashSet and LinkedHashMap for implementing cache applications

HashMap 
1) The underlying data structure is Hashtable. 
2) Insertion order is not preserved. 
3) introduced in 1.2.v. 

LinkedHashMap 
1) The underlying data structure is a combination of Hashtable+ LinkedList.
2) Insertion order is preserved. 
3) Introduced in 1.4v. 

Java.util.Collections.frequency() in Java
---------------------------------------
public static int frequency(Collection c, Object o) 
parameters:
c: Collection in which to determine the frequency of o.
o: Object whose frequency is to be determined.
It throws Null Pointer Exception if the Collection c is null.

How to get frequency of each word in a paragraph of strings?


import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
 
public class WordFrequency{
 
    public static void main(String args[]){
        String paragraph= "ab bc ab bc abbbb bc ab cd ef bc bc ";
         
        String eachWord[]=paragraph.split(" ");
         
        ArrayList listEachWord = new ArrayList(Arrays.asList(eachWord));
        LinkedHashMap numeach = new LinkedHashMap ();
          
        for(int i=0;i&lt;eachWord.length;i++){
         numeach.put(eachWord[i],Collections.frequency(listEachWord,eachWord[i]));  
        }
          
          
        System.out.println(numeach);
    }
}



public class GFG 
{ 
    public static void main(String[] args) 
    { 
        // Let us create a list with 4 items 
        ArrayList<String> list = new ArrayList<String>(); 
        list.add("code"); 
        list.add("code"); 
        list.add("quiz"); 
        list.add("code"); 
      
        // count the frequency of the word "code" 
        System.out.println("The frequency of the word code is: "+  Collections.frequency(list, "code"));  
    } 
} 

output : The frequency of the word code is: 3

************************************************************************************************************

IdentityHashMap:
-----------------

When to prefer IdentityHashMap over HashMap

According to Oracle docs , IdentityHashMap  class is not a general purpose Map implementation , 
while WeakHashMap class implements the Map interface , 
it intentionally violates Map's general contract , 
which mandates the use of the equals method when comparing objects. 
This class is designed for use only in the rare cases wherein reference-equality semantics are required.

A typical use of this class is topology-preserving object graph transformations , 
such as serialization and deep copying . To perform such a transformation , 
a program must maintain a "node table" that keeps track of all the object references that have already been processed.
The node table must not equate distinct objects even if they happen to be equal.

Another typical use of this class is to maintain proxy objects.
 For example , a debugging facility might wish to maintain a  proxy object for each object in the program being debugged.
`

1. Equality used(Reference Equality instead of Object Equality) : IdentityHashMap uses reference equality to compare keys and values while HashMap uses object equality to compare keys and values .
for example :

Suppose we have two keys k1 and k2

In HashMap :
two keys are considered equal   if and only if (k1==null ? k2==null  : k1.equals(k2))
// object equality i.e using equals() method to compare objects


In IdentityHashMap :
two keys are considered equal  if and only if (k1 == k2)   
//reference equality  i.e  using == operator  to compare objects

2. Map's contract violation :  IdentityHashMap implements the Map interface,  it intentionally violates the Map general contract ,
   which mandates the use of equals method when comparing objects.
   HashMap also implements Map interface but it does not violate the Map general contract  as it uses equals method  to compare objects .

3. Hashcode method :   IdentityHashMap does not use hashCode() method instead it uses System.identityHashCode() to find bucket location.
   HashMap uses hashCode() method to find bucket location. 

4. Immutable keys : IdentityHashMap does not require keys to be immutable as it does not relies on equals() and hashCode() method.
   To safely store the object in HashMap keys must be immutable.

5. Performance : According to IdentityHashMap Oracle docs,
   IdentityHashMap will yield better performance than HashMap(which uses chaining rather than linear probing Hashtable)  for many jre implementations and operation mixes

6. Implementation : Both IdentityHashMap and HashMap are  Hashtable based implementation of Map interface. 
   IdentityHashMap is a simple linear probe hashtable  while HashMap uses chaining instead of linear probe in hashtable. 

7. Initial capacity of default constructor : Initial capacity of HashMap is 16 by default .  Initial capacity of IdentityHashMap is 21 by default.

8. Added to jdk : IdentityHashMap is added to jdk in java version  1.4 . HashMap class is introduced to the java development kit in java version 1.2 .


$$$$$$$$$$
Linear probing is a scheme in computer programming for resolving collisions in hash tables, 
data structures for maintaining a collection of key–value pairs and looking up the value associated with a given key.

-----------------------------------------------------------------------------------------------
					IdentityHashMap			HashMap		

Equality used     			Reference(==)      		Object(equals method)

Maps contract violation			Yes		   		No

HashCode method used			System.identityHashCode()	Object class hashCode() method

Immutable keys				No requirement			Yes

Performance				Fast				Slow in comparision

Implementation				linear-probe			chaining

Initial capacity 
of Default constructor 			21				16

Added to jdk				jdk 1.4				jdk 1.2


**********************************************************************************************************************************************

WeakHashMap: 
It is exactly same as HashMap except the following differences:  
In the case of normal HashMap, an object is not eligible for GC even though it doesn't have any references if it is associated with HashMap. 
That is HashMap dominates garbage collector. But in the case of WeakHashMap if an object does not have any references then it's always eligible for GC 
even though it is associated with WeakHashMap that is garbage collector dominates WeakHashMap. 


In order to understand the data structure, we’ll use it here to roll out a simple cache implementation. However, 
keep in mind that this is meant to understand how the map works, and creating your own cache implementation is almost always a bad idea.
Simply put, the WeakHashMap is a hashtable-based implementation of the Map interface, with keys that are of a WeakReference type.
An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use, 
meaning that there is no single Reference that point to that key. 
When the garbage collection (GC) process discards a key, its entry is effectively removed from the map, 
so this class behaves somewhat differently from other Map implementations.

Using a simple HashMap will not be a good choice because the value objects may occupy a lot of memory.
What’s more, they’ll never be reclaimed from the cache by a GC process, 
even when they are not in use in our application anymore.

Ideally, we want a Map implementation that allows GC to automatically delete unused objects.
When a key of a big image object is not in use in our application in any place, that entry will be deleted from memory.


WeakHashMap<UniqueImageName, BigImage> map = new WeakHashMap<>();
BigImage bigImage = new BigImage("image_id");
UniqueImageName imageName = new UniqueImageName("name_of_big_image");
 
map.put(imageName, bigImage);
assertTrue(map.containsKey(imageName));
 
imageName = null;
System.gc();
 
await().atMost(10, TimeUnit.SECONDS).until(map::isEmpty);

We’re creating a WeakHashMap instance that will store our BigImage objects. 
We are putting a BigImage object as a value and an imageName object reference as a key. 
The imageName will be stored in a map as a WeakReference type.

Next, we set the imageName reference to be null, therefore there are no more references pointing to the bigImage object. 
The default behavior of a WeakHashMap is to reclaim an entry that has no reference to it on next GC, 
so this entry will be deleted from memory by the next GC process.

**************************************************************************************************************************************************************
sortedMap:
----------------

NavigatableMap 
-------------

TreeMap 
---------

HashTable
------------

Properties 
----------
*******************************************************************************************************************************************************
Queue
------

The Java Queue interface, java.util.Queue represents a data structure designed to have elements inserted at the end of the queue,
and elements removed from the beginning of the queue. This is similar to how a queue in a supermarket works.


The Java Queue interface is a subtype of the Java Collection interface. 
It represents an ordered sequence of objects just like a Java List, but its intended use is slightly different.

Since Queue is an interface you need to instantiate a concrete implementation of the interface in order to use it. 
You can choose between the following Queue implementations in the Java Collections API:
java.util.LinkedList
java.util.PriorityQueue

Queue is used when things don’t have to be processed immediatly, 
but have to be processed in First InFirst Out order like Breadth First Search. 
This property of Queue makes it also useful in following kind of scenarios.
1) When a resource is shared among multiple consumers. Examples include CPU scheduling, Disk Scheduling.
2) When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc.

1. Queue is child interface of Collections.
2. If we want to represent a group of individual objects prior (happening before something else) to processing then we should go for Queue interface. 
3. Usually Queue follows first in first out(FIFO) order but based on our requirement we can implement our own order also. 
4. From 1.5v onwards LinkedList also implements Queue interface.
5. LinkedList based implementation of Queue always follows first in first out order.

Assume we have to send sms for one lakh mobile numbers , 
before sending messages we have to store all mobile numbers into Queue so that for the first inserted number first message will be triggered(FIFO).

LinkedList is a pretty standard queue implementation.
PriorityQueue stores its elements internally according to their natural order 
(if they implement Comparable), or according to a Comparator passed to the PriorityQueue.


Queue interface methods: 
0. boolean add(Object o);  to add it will add elements the Queue if it is possible with out throwing capaicty instructions if memory is full it throw illegal state exception.
1. boolean affer(Object o);  To add an object to the Queue.
2. Object poll() ;  To remove and return head element of the Queue, if Queue is empty then we will get null. 
3. Object remove();  To remove and return head element of the Queue. If Queue is empty then this method raises Runtime Exception saying NoSuchElementException.
4. Object peek();  To return head element of the Queue without removal, if Queue is empty this method returns null. 
5. Object element();  It returns head element of the Queue and if Queue is empty then it will raise Runtime Exception saying NoSuchElementException. 



Exmaple
---------
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;

public class Practise {
	 
	
	private void test() {
	  //  Queue<String> waitingQueue = new LinkedList<>();   -------->>Jennifer
									   Angelina
									   Johnny
								           Sachin
	        Queue<String> waitingQueue = new PriorityQueue<>();----->>Angelina
//priorityQueue is some natural sorting oreder or by comparator		  Jennifer
									  Johnny
									  Sachin

	        waitingQueue.add("Jennifer");
	        waitingQueue.add("Angelina");
	        waitingQueue.add("Johnny");
	        waitingQueue.add("Sachin");

	
	       waitingQueue.stream().forEach(System.out::println);
	        
	}

public static void main(String[] args) {
		
		Practise p = new Practise();
		p.test();
		
	}
}


PriorityQueue: 
A priority is collection of items all the same type 
it enables efficent insertion of the elements and efficent removal of the elements 
removal is based on natural order by comparator 
priority queue is also an abstract data type

Note: its not going to work same as FIFO
Minimum item has highest priority 

33 84 19 25 100  --> in this queue 19 has  highest priority

Note: A minimum heap is the most efficent implementation of a priority Queue

1. PriorityQueue is a data structure to represent a group of individual objects prior to processing according to some priority.
2. The priority order can be either default natural sorting order (or) customized sorting order specified by Comparator object. 
3. If we are depending on default natural sorting order then the objects must be homogeneous and Comparable otherwise we will get ClassCastException.
4. If we are defining our own customized sorting order by Comparator then the objects need not be homogeneous and Comparable. 
5. Duplicate objects are not allowed.
6. Insertion order is not preserved but all objects will be inserted according to some priority. 
7. Null is not allowed even as the 1st element for empty PriorityQueue.Otherwise we will get the "NullPointerException". 

Constructors: 
1. PriorityQueue q=new PriorityQueue();  Creates an empty PriorityQueue with default initial capacity 11 and default natural sorting order.
2. PriorityQueue q=new PriorityQueue(int initialcapacity,Comparator c); 
3. PriorityQueue q=new PriorityQueue(int initialcapacity); 
4. PriorityQueue q=new PriorityQueue(Collection c); 
5. PriorityQueue q=new PriorityQueue(SortedSet s);

Deque:(Double ended Queue)
------
Deque supports elements insertion and removel form the both the ends 


The general-purpose implementations include LinkedList and ArrayDeque classes.
The Deque interface supports insertion, removal and retrieval of elements at both ends. 
The ArrayDeque class is the resizable array implementation of the Deque interface, 
whereas the LinkedList class is the list implementation.

The interface defines methods to access the elements from the both the ends of the deque
methods are provided to insert and remove and examine the element
each of these methods exits in two forms one throw the exception if operation fails
other retutrns null are false

		FirstElement (head)				LastElement (Tail)
		
		ThrowsException     specialValue		ThrowsException     specialValue

insert 		addFirst(e)      |  offerFirst(e)		addLast(e)       |  offerLast(e)

remove 		removeFirt()     |  pollFirst()			removeLast()     |  pollLast()

examine		getFirst()       |  peekFirst()			getLast()        |  peekLast()


DEQUE as QUEUE
----------------
Deque interface extends the Queue interface. when a deque is used as a queue FIFO behaviour results 
Elements are added at the end of the deque and removed from the beginning  
The methods inherited from the Queue interface are precisely equivalent to Deque methods as indicated

QueueMethod 			Equivalent Deque Method 
add(e)				addLast(e)
offer(e)			offerLast(e)	
remove()			removeFirst()
poll()				pollFirst()
element()			getFirst()
peek()				peekFirst()

DEQUE as STACK
---------------
Deques can also be used as LIFO this inerface should be used in preference to the legacy Stack class
when Deque is used as stack elements are pushed and poped from the beginning of the deque 
stack method are precisely equivalent Deque.

stack method  			Equienlnt Deque method 
-----------			---------------------
push(e)				addFirst(e)
pop()				removeFirst()
peek()				peekFirst()

ArrayDeque:
-----------

An ArrayDeque (also known as an “Array Double Ended Queue”, pronounced as “ArrayDeck”) 
is a special kind of a growable array that allows us to add or remove an element from both sides.

An ArrayDeque implementation can be used as a Stack (Last-In-First-Out) or a Queue(First-In-First-Out).

Under the hood, the ArrayDeque is backed by an array which doubles its size when it gets filled.

Initially, the array is initialized with a size of 16.
It’s implemented as a double-ended queue where it maintains two pointers namely a head and a tail.

ArrayDeque as Stack
-----------------
deque.push("First");
deque.push("Second");

deque.pop()

ArrayDeque as a Queue
--------------------
deque.offer("First");
deque.offer("Second");

deque.poll()

While when user polls an element, it sets the element at the head position to null so the element could be garbage collected,
and then moves the head pointer.

Notes:
It’s not thread-safe
Null elements are not accepted
Works significantly faster than the synchronized Stack
Is a faster queue than LinkedList due to the better locality of reference
Most operations have amortized constant time complexity
An Iterator returned by an ArrayDeque is fail-fast
ArrayDeque automatically doubles the size of an array when head and tail pointer meets each other while adding an element


What is the difference b/w LinkedList and ArrayDeque?

LinkedList in Java is basically a doubly Linked List (a very profound statement, I know…).
There is some extra baggage that comes along with linked list that can make it expensive: 
using memory to hold objects and to contain ‘links’ that point to other objects, related objects in non-contiguous memory (which slows down iteration), etc.

So why is the ArrayDeque much faster? First of all, it removes the need for extra memory used to create a ‘link’ that points to other objects.
 An ArrayDeque is backed by a circular array (hopefully that was obvious by the name), 
so all objects are ordered next to each other in the array. The objects sitting contiguously in memory also helps out in cache hits as well.