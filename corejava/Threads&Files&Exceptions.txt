Threads  
-------

We can define a Thread in the following 2 way
1. By extending Thread class.
2. By implementing Runnable interface

If multiple Threads are waiting to execute then which Thread will execute 1st is
decided by "Thread Scheduler" which is part of JVM.

For every Thread the required mandatory activities like registering the Thread with
Thread Scheduler will takes care by Thread class start() method and programmer is
responsible just to define the job of the Thread inside run() method.

Among the 2 ways of defining a Thread, implements Runnable approach is
always recommended.In the 1st approach our class should always extends Thread class there is no
chance of extending any other class hence we are missing the benefits of
inheritance.But in the 2nd approach while implementing Runnable interface we can extend
some other class also. Hence implements Runnable mechanism is recommended
to define a Thread


Note: We can get current executing Thread object reference by using
Thread.currentThread() method.

Every Thread in java has some priority it may be default priority generated by
JVM (or) explicitly provided by the programmer

Thread. MIN_PRIORITY----------1
Thread. MAX_PRIORITY----------10
Thread. NORM_PRIORITY--------5

Thread scheduler uses these priorities while allocating CPU

If 2 Threads having the same priority then we can't expect exact execution order
it depends on Thread scheduler whose behavior is vendor dependent

The allowed values are 1 to 10 otherwise we will get runtime exception saying
"IllegalArgumentException".


public static native void yield();
yield() method causes "to pause current executing Thread for giving the chance
of remaining waiting Threads of same priority".

Join():
If a Thread wants to wait until completing some other Thread then we should go for
join() method.
Example: If a Thread t1 executes t2.join() then t1 should go for waiting state until
completing t2.
1. public final void join()throws InterruptedException
2. public final void join(long ms) throws InterruptedException
3. public final void join(long ms,int ns) throws InterruptedException



Note :
If main thread calls join() on child thread object and child thread called join() on main
thread object then both threads will wait for each other forever and the program will be
hanged(like deadlock if a Thread class join() method on the same thread itself then the
program will be hanged ).

Sleep() method:
If a Thread don't want to perform any operation for a particular amount of time then
we should go for sleep() method.
1. public static native void sleep(long ms) throws InterruptedException
2. public static void sleep(long ms,int ns)throws InterruptedException


How a Thread can interrupt another thread ?
If a Thread can interrupt a sleeping or waiting Thread by using interrupt()(break off)
method of Thread class.
public void interrupt();



Files
-------------------------------------------------------------------------------------------------------------------------
File f=new File("abc.txt");

This line 1st checks whether abc.txt file is already available (or) not if it is already
available then "f" simply refers that file.
If it is not already available then it won't create any physical file just creates a java File
object represents name of the file.

1. File f=new File(String name);
Creates a java File object that represents name of the file or directory in current
working directory.
2. File f=new File(String subdirname,String name);
Creates a File object that represents name of the file or directory present in
specified sub directory.
3. File f=new File(File subdir,String name);

methods of a file class
boolean exists();
boolean createNewFile();
boolean mkdir();
boolean isFile();-->it reprents the physical file are not
boolean isDirectory();
String[] list();-->returns the number of files present in the directory are subdirectory
long length();-- returns the number of cahracters present in a file.
boolean delete();

FileInputStream
Java FileInputStream class obtains input bytes from a file. It is used for reading byte-oriented data (streams of raw bytes) such as image data, audio, video etc

BufferedOutputStream 
Java BufferedOutputStream class is used for buffering an output stream. It internally uses buffer to store data. It adds more efficiency than to write data directly into a stream. So, it makes the performance fast.

BufferedInputStream 
Java BufferedInputStream class is used to read information from stream. It internally uses buffer mechanism to make the performance fast



FileWriter:
By using FileWriter object we can write character data to the file.

FileWriter fw=new FileWriter(String name);
FileWriter fw=new FileWriter(File f);

Instead of overriding if we want append operation then we should go for the following 2
constructors.
FileWriter fw=new FileWriter(String name,boolean append);
FileWriter fw=new FileWriter(File f,boolean append);
1. write(int ch);
To write a single character to the file.
2. write(char[] ch);
To write an array of characters to the file.
3. write(String s);
To write a String to the file.
4. flush();
To give the guarantee the total data include last character also written to the file.
5. close();
To close the stream.


****The main problem with FileWriter is we have to insert line separator manually ,
which is difficult to the programmer. ('\n') And even line separator varing from system to system.

FileReader:
By using FileReader object we can read character data from the file.
Constructors:
FileReader fr=new FileReader(String name);
FileReader fr=new FileReader (File f);

1. int read();
It attempts to read next character from the file and return its Unicode value. If
the next character is not available then we will get -1.
2. int i=fr.read();
3. System.out.println((char)i);
As this method returns unicode value , while printing we have to perform type
casting.
4. int read(char[] ch);
It attempts to read enough characters from the file into char[] array and returns
the no of characters copied from the file into char[] array.
5. File f=new File("abc.txt");
6. Char[] ch=new Char[(int)f.length()];
7. void close();



**************Usage of FileWriter and FileReader is not recommended because :
1. While writing data by FileWriter compulsory we should insert line separator(\n)
manually which is a bigger headache to the programmer.
2. While reading data by FileReader we have to read character by character
instead of line by line which is not convenient to the programmer.
3. To overcome these limitations we should go for BufferedWriter and
BufferedReader concepts.


BufferedWriter*****
By using BufferedWriter object we can write character data to the file.
Constructors:
BufferedWriter bw=new BufferedWriter(writer w);
BufferedWriter bw=new BufferedWriter(writer w,int buffersize)


*******Note: BufferedWriter never communicates directly with the file it should communicates
via some writer object.

1. BufferedWriter bw=new BufferedWriter("cricket.txt"); (invalid)
2. BufferedWriter bw=new BufferedWriter (new File("cricket.txt")); (invalid)
3. BufferedWriter bw=new BufferedWriter (new FileWriter("cricket.txt")); (valid)

Methods:
1. write(int ch);
2. write(char[] ch);
3. write(String s);
4. flush();
5. close();
6. newline();
Inserting a new line character to the file.
When compared with FileWriter which of the following capability(facility) is available
as method in BufferedWriter.
1. Writing data to the file.
2. Closing the writer.
3. Flush the writer.
4. Inserting newline character.


****Note : When ever we are closing BufferedWriter automatically underlying writer will be
closed and we are not close explicitly

BufferedReader****
This is the most enhanced(better) Reader to read character data from the file.

Constructors:
BufferedReader br=new BufferedReader(Reader r);
BufferedReader br=new BufferedReader(Reader r,int buffersize);

Note: BufferedReader can not communicate directly with the File it should
communicate via some Reader object.

The main advantage of BufferedReader over FileReader is we can read data line by line
instead of character by character


Methods:
1. int read();
2. int read(char[] ch);
3. String readLine();
It attempts to read next line and return it , from the File. if the next line is not
available then this method returns null.
4. void close();

Note:
Whenever we are closing BufferedReader automatically underlying FileReader
will be closed it is not required to close explicitly.Even this rule is applicable for BufferedWriter also.


PrintWriter:
This is the most enhanced Writer to write text data to the file.

By using FileWriter and BufferedWriter we can write only character data to the
File but by using PrintWriter we can write any type of data to the File.

Constructors:
PrintWriter pw=new PrintWriter(String name);
PrintWriter pw=new PrintWriter(File f);
PrintWriter pw=new PrintWriter(Writer w);
PrintWriter can communicate either directly to the File or via some Writer object also.
Methods:
1. write(int ch);
2. write (char[] ch);
3. write(String s);
4. flush();
5. close();
6. print(char ch);
7. print (int i);
8. print (double d);
9. print (boolean b);
10. print (String s);
11. println(char ch);
12. println (int i);
13. println(double d);
14. println(boolean b);
15. println(String s);


*******What is the difference between write(100) and print(100)?
In the case of write(100) the corresponding character "d" will be added to the File but
in the case of print(100) "100" value will be added directly to the File


Note 1:
1. The most enhanced Reader to read character data from the File isBufferedReader.
2. The most enhanced Writer to write character data to the File is PrintWriter.
Note 2:
1. In general we can use Readers and Writers to handle character data. Where as
we can use InputStreams and OutputStreams to handle binary data(like images,
audio files, video files etc).
2. We can use OutputStream to write binary data to the File and we can use
InputStream to read binary data from the File.

Serialization: (1.1 v)
1. The process of saving (or) writing state of an object to a file is called serialization
2. but strictly speaking it is the process of converting an object from java supported
form to either network supported form (or) file supported form.

De-Serialization:
1. The process of reading state of an object from a file is called DeSerialization
2. but strictly speaking it is the process of converting an object from file supported
form (or) network supported form to java supported form

Note:****
	1. We can perform Serialization only for Serilizable objects.
	2. An object is said to be Serilizable if and only if the corresponding class
	implements Serializable interface.
	3. Serializable interface present in java.io package and does not contain any
	methods. It is marker interface. The required ability will be provided
	automatically by JVM.
	4. We can add any no. Of objects to the file and we can read all those objects from
	the file but in which order we wrote objects in the same order only the objects
	will come back. That is order is important.
	5. If we are trying to serialize a non-serializable object then we will get
	RuntimeException saying "NotSerializableException".



Transient keyword:
1. transient is the modifier applicable only for variables.
2. While performing serialization if we don't want to save the value of a particular
variable to meet security constant such type of variable , then we should declare
that variable with "transient" keyword.
3. At the time of serialization JVM ignores the original value of transient variable
and save default value to the file .

Static&Transiant
1. static variable is not part of object state hence they won't participate in
serialization because of this declaring a static variable as transient there is no
use
Final&Transiant
1. final variables will be participated into serialization directly by their values.
Hence declaring a final variable as transient there is no use.
//the compiler assign the value to final variable



We can implements customized serialization by using the following two methods.
1. 
 throws Exception.
This method will be executed automatically by jvm at the time of serialization.
It is a callback method. Hence at the time of serialization if we want to perform
any extra work we have to define that in this method only.
(prepare encrypted password and write encrypted password seperate to the file )
2. private void readObject(ObjectInputStream is) throws Exception.
This method will be executed automatically by JVM at the time of
Deserialization. Hence at the time of Deserialization if we want to perform any
extra activity we have to define that in this method only.
(read encrypted password , perform decryption and assign decrypted password
to the current object password variable )


At the time of Account object serialization JVM will check is there any writeObject()
method in Account class or not. If it is not available then JVM is responsible to perform
serialization(default serialization). If Account class contains writeObject() method then
JVM feels very happy and executes that Account class writeObject() method. The same
rule is applicable for readObject() method also.


Case 1:
If parent class implements Serializable then automatically every child class by default
implements Serializable. That is Serializable nature is inheriting from parent to child.
Hence even though child class doesn't implements Serializable , we can serialize child
class object if parent class implements serializable interface.

Even though parent class does not implements Serializable we can serialize child
object if child class implements Serializable interface.
2. At the time of serialization JVM ignores the values of instance variables which
are coming from non Serializable parent then instead of original value JVM
saves default values for those variables to the file.
3. At the time of Deserialization JVM checks whether any parent class is non
Serializable or not. If any parent class is non Serializable JVM creates a separate
object for every non Serializable parent and shares its instance variables to the
current object









